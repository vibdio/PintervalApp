開発方針：

# 開発モデル（結論）

1. **イベント契約（Event Contract）を先に定義**

   * イベント名・ペイロード型・発生源（Producer）・責務（Consumer）・順序/優先度・排他キー・キャンセル可否を1枚にする（JSON/TS型で良い）。
   * 「いつ・誰が・何の前/後に発火するか」を明文化します。

2. **単一のイベントバスで“段階（phase）＋優先度（priority）”を制御**

   * `pre` → `main` → `post` の3段階に分け、**同一段階内は priority降順・同一優先度は登録順**で実行。
   * UI更新系は `post`、バリデーション/ガードは `pre` に寄せると堅い。

3. **排他（lock）とキャンセル（AbortController）を標準装備**

   * 同一ドキュメントや同一リクエストに関するイベントは `lockKey` で直列化。
   * 直近の操作だけを有効化し、古い非同期処理は **必ず abort** して中断（“二重送信・二重描画”を防ぐ）。

4. **状態機械（Statechart）で“何を待っているか”を明示**

   * 例：`Idle → Loading → Ready → Signing → Completed` のように状態遷移表を先に作る。
   * ハンドラ内で分岐しない（＝**状態が不一致ならイベントを捨てる/保留する**）。
   * 実装は XState 等でも自前でもOK。まずは薄い実装でも「状態→許可イベント→遷移先」を固定化するのが肝。

5. **トランザクションID（txId）で1ユーザー操作をひとまとめ**

   * クリックやドラッグ開始で `txId` を発行し、関連する下流イベントに伝播。
   * ログ/メトリクス/ロールバックの単位になります。

6. **“発火タイミング”は原則マイクロタスク境界で整える**

   * DOMを触る直前/直後の順序事故を避けるため、`queueMicrotask` か `Promise.resolve().then()` を使って **発火を次のtickに送る**（ただし必要最小限）。

7. **観測可能性（Observability）を最初から組み込み**

   * 既存の `js/debug/event-tracer.js` を常時オンにできるトグルを用意し、`window.__eventLog__` / `console.table` で直近の発火キューを確認できるようにする。
   * 失敗/キャンセル/ロック待ちも記録する。


# 移行の実務手順（最短で効く順）

1. **トレーサを常時ONにして現状把握**

   * `attachEventTracer(bus)` を初期化時に呼ぶ（`js/debug/event-tracer.js`）。
   * 操作後に `window.__eventLog__` / `console.table` で「どのイベントがどの順で、どこで止まったか」を確認。

2. **UI更新をすべて `post` フェーズに寄せる**

   * DOM操作が `pre/main` に紛れていると順序事故の温床になります。

3. **ドキュメント単位の `lockKey` を徹底**

   * 同じドキュメントIDに跨る処理は必ず直列化。
   * 連打・戻る/進む・タブ切替でも破綻しなくなります。

4. **非同期は必ず `AbortSignal` を受け取る**

   * `fetch`・`setTimeout`・自作の長処理にも `signal` を渡し、`aborted` を見て中断。

5. **“状態→許可イベント→遷移”の表を作り、ガードを入れる**

   * 当面は薄い実装でもOK。イベントの“捨て方”を決めておくのが重要です。

6. **エラー/キャンセルの終着点を1つに**

   * `sign:error` のような統一チャンネルでUI通知・リトライ方針を決定。

---

# よくある“発火しない”根本原因と、このモデルでの対処

* **非同期競合**（前の処理が後の処理を上書き/無効化）
  → `emitSwitch + lockKey + AbortController` で常に「最後の操作だけ有効」。

* **DOM準備前の発火**（要素未生成/未マウント）
  → UI更新は `post`、必要なら `queueMicrotask` で次tickに送る。

* **ハンドラの副作用が相互依存**（AがBを前提、でもBが後に実行）
  → `phase/priority` で実行順を契約化。状態機械で依存を“明文化”。

* **グローバルに散ったリスナ**（誰が先に動くか不定）
  → 単一バスに集約して登録。契約表に“責務と順序”を記述。

* **古いリクエストが帰ってきてUIを壊す**
  → すべての非同期に `signal` を渡し、**古いものは必ず abort**。

---

# 最小の運用ルール（チーム共通）

* 新しい機能は必ず **イベント契約PR** を先に出す（イベント名/型/phase/priority/lockKey/キャンセル可否）。
* DOM更新は `post` 限定。
* すべての非同期は `ctx.signal` を受け取り、キャンセルに応答。
* 1操作＝1 `txId`。ログは `txId` で結ぶ。
* 発火バグは **再現ログ（event tracerのスクショ）** を必ず添付。